# /// script
# dependencies = [
#   "requests",
#   "matplotlib",
#   "seaborn",
#   "pandas",
#   "chardet"
# ]
# ///
import os
import requests
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import chardet
import sys
import base64
import json


def detect_encoding(file_path):
    """
    Paramaters: file_path
    Returns: the encoding of the file
    """
    try:
        with open(file_path, "rb") as f:
            raw_data = f.read()
        result = chardet.detect(raw_data)
        return result["encoding"]
    except Exception as e:
        print(f"Error detecting file encoding: {e}")
        sys.exit(1)


auth_token = os.environ["AIPROXY_TOKEN"]


# Utility Function to encode the image
def encode_image(image_path):
    """
    Parameters: image_path
    Returns: base64 encoded string for the image
    """
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode("utf-8")


# Utility function to talk to llm
def question_llm(question, context=""):
    """
    parameters:
        1. question: the question you want to ask to the llm.
        2. context(Optional): the context you want to add to the question.

    Returns:
        The response generated by the llm
    """
    res = requests.post(
        "https://aiproxy.sanand.workers.dev/openai/v1/chat/completions",
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "model": "gpt-4o-mini",
            "messages": [
                {
                    "role": "system",
                    "content": "You are a well experienced data scientist and analyst. You have been provided some data and you need to narrate a story from it. Go ahead and make it creative",
                },
                {"role": "user", "content": f"{question}. \n Context: f{context}"},
            ],
        },
    )

    result = res.json()

    print(result)
    return result["choices"][0]["message"]["content"] if "error" not in result else None


# Utility function to talk to llms but with images
def ask_llm_with_image(imagePath, content):
    """
    Parameters:
        1. imagePath: the path of the image you want to pass to the llm
        2. content: the question you want to ask to the llm.

    Returns:
        The response generated by the llm
    """
    res = requests.post(
        "https://aiproxy.sanand.workers.dev/openai/v1/chat/completions",
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "model": "gpt-4o-mini",
            "messages": [
                {
                    "role": "system",
                    "content": "You are a well experienced data scientist and analyst. You have been provided with an image which are most probably some graphs and you have to answer the questions based on the graph.",
                },
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": f"{content}"},
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/png;base64,{encode_image(imagePath)}",
                                "detail": "low",
                            },
                        },
                    ],
                },
            ],
        },
    )

    result = res.json()

    return result["choices"][0]["message"]["content"] if "error" not in result else None


# Utility function to ask llm to suggest a plot
def ask_llm_to_suggest_plot(df):
    """
    Finds a plot to use for visualising data
        Parameters: df,
        Returns: The suggested plot and columns to use for the plot
    """
    response = requests.post(
        "https://aiproxy.sanand.workers.dev/openai/v1/chat/completions",
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "model": "gpt-4o-mini",
            "response_format": {"type": "json_object"},
            "tools": [
                {
                    "type": "function",
                    "function": {
                        "name": "find_plot",
                        "description": "Returns a good plot name by looking at the columns of the dataframe. Also returns the columns to be used for the plot.",
                        "parameters": {
                            "type": "object",
                            "properties": {
                                "plot_name": {
                                    "type": "string",
                                    "description": "Name of the plot",
                                },
                                "columns": {
                                    "type": "array",
                                    "items": {"type": "string"},
                                    "description": "Columns to be used for the plot",
                                },
                                "plot_type": {
                                    "type": "string",
                                    "description": "Type of plot, e.g., bar chart, pie chart, etc.",
                                },
                            },
                        },
                    },
                    "required": ["columns", "plot_name", "plot_type"],
                },
            ],
            "tool_choice": {"type": "function", "function": {"name": "find_plot"}},
            "messages": [
                {
                    "role": "system",
                    "content": "Identify columns and suggest a plot based on the dataframe. Return as json.",
                },
                {
                    "role": "user",
                    "content": f"{df.head().to_string()}",
                },
            ],
        },
    )

    result = response.json()

    print(result)

    return json.loads(
        result["choices"][0]["message"]["tool_calls"][0]["function"]["arguments"]
    )


# Utility function to ask llm to code and return a plot
def ask_llm_to_plot(df, plot_details):
    """
    Codes to return a plot to use for visualising data
        Parameters:
            1. df
            2.plot_details
        Returns: The  plot (matplotlib object
    """
    response = requests.post(
        "https://aiproxy.sanand.workers.dev/openai/v1/chat/completions",
        headers={"Authorization": f"Bearer {auth_token}"},
        json={
            "model": "gpt-4o-mini",
            "messages": [
                {
                    "role": "system",
                    "content": "You are an expert python developer. You have been provided a plotname, a dataframe example and column names. Write a python function to generate the plot using only matplotlib and seaborn. The dataframe is passed as a parameter of the function. Use the 'uv' package manager. Generate only the function code, nothing extra. \n Also call the function using the argument 'dataset' and save the plot in the current directory with the name 'custom_llm_plot.png'",
                },
                {
                    "role": "user",
                    "content": f"Plot name: {plot_details['plot_type']} \n Dataframe example: {df.head().to_string()} \n Columns: {plot_details['columns']}",
                },
            ],
        },
    )

    result = response.json()

    print(result)

    return result["choices"][0]["message"]["content"] if "error" not in result else None


# Utility function to open file.
def open_file(file_path):
    """
    Parameters: file_path
    Returns: Returns the dataframe of the file
    """
    df = pd.read_csv(file_path, encoding=detect_encoding(file_path))
    return df


# Utitlity function to save visualisations
def save_visualisation(visualisation, outputDir, filename):
    """
    Parameters:
        1. visualisation: the visualisation object (matplotlib figure)
        2. outputDir: the directory to save the visualisation
        3. filename: the name of the file to save
    """
    try:
        visualisation.tight_layout()
        visualisation.savefig(os.path.join(outputDir, filename), bbox_inches="tight")
        visualisation.close()
    except Exception as e:
        print("An error occured while saving visualisation", e)


# Function to summarize dataset
def summarize(dataset):
    """
    Parameters: dataset (A pandas dataframe)
    Returns: summary of the dataset
    """
    # Describing dataset
    descriptive_summary = dataset.describe(include="all").transpose()

    summary = {
        "row_count": len(dataset),
        "column_count": len(dataset.columns),
        "columns": dataset.dtypes.to_dict(),
        "missing_values": dataset.isnull().sum().to_dict(),
        "descriptive_summary": descriptive_summary[
            ["mean", "std", "min", "25%", "50%", "75%", "max"]
        ]
        if not descriptive_summary.empty
        else None,
    }

    return summary


# Function to find correlation matrix and plot it
def visualise_correlation(dataset, outputDir):
    """
    Parameters:
    1. dataset: A pandas dataframe
    2. outputDir (A string): Directory to save the visualisation
    Returns:
    Correlation matrix using pandas.corr()
    """
    filtered_numeric_dataset = dataset.select_dtypes(include=["number"])
    if filtered_numeric_dataset.empty:
        print("No numeric columns found")
        return None

    correlation_matrix = filtered_numeric_dataset.corr()

    # Printing correlation matrix
    print("Correlation Matrix")
    print(correlation_matrix)

    # Plotting the figure
    plt.figure(figsize=(12, 8))
    sns.heatmap(
        correlation_matrix, annot=True, cmap="coolwarm", fmt=".3f", linewidth=0.8
    )
    plt.title("Correlation Matrix Heatmap")
    save_visualisation(plt, outputDir, "correlation_matrix_heatmap.png")
    print("Saved correlation matrix heatmap")

    return correlation_matrix


# Function to visualise outliers
def visualise_outliers(dataset, outputDir):
    """
    Parameters:
    1. dataset: A pandas dataframe
    2. outputDir (A string): Directory to save the visualisation
    """
    filtered_numeric_dataset = dataset.select_dtypes(include=["number"])
    if filtered_numeric_dataset.empty:
        print("No numeric columns found")
        return None

    # Plotting the figure
    plt.figure(figsize=(12, 6))
    sns.boxplot(data=filtered_numeric_dataset)
    plt.title("Outliers Boxplot")

    plt.xticks(rotation=90)  # Changing orientation of the x-axis labels

    save_visualisation(plt, outputDir, "outliers_boxplot.png")
    print("Saved Outlier Boxplot heatmap")


# Function to visualise time series data
def visualise_time_series(dataset, outputDir):
    """
    Parameters:
    1. dataset: A pandas dataframe
    2. outputDir (A string): Directory to save the visualisation
    """
    if "Date" in dataset.columns:
        try:
            dataset["Date"] = pd.to_datetime(dataset["Date"])
            dataset = dataset.sort_values("Date")
            numeric_columns = dataset.select_dtypes(include=["number"]).columns
            if numeric_columns.empty:
                print("No numeric columns for time series analysis.")
                return
            plt.figure(figsize=(12, 6))
            sns.lineplot(data=dataset, x="Date", y=numeric_columns[0])
            plt.title(f"Time Series Analysis for {numeric_columns[0]}")
            save_visualisation(plt, outputDir, "time_series.png")
            return plt
        except Exception as e:
            print(f"Error in Time Series Analysis: {e}")
    else:
        print("Date column not found for time series analysis.")


# Function to visualise geographic data
def visualise_geographic_analysis(dataset, outputDir):
    """
    Parameters:
    1. dataset: A pandas dataframe
    2. outputDir (A string): Directory to save the visualisation
    Returns: None
    """
    if "Latitude" in dataset.columns and "Longitude" in dataset.columns:
        plt.figure(figsize=(10, 8))
        sns.scatterplot(
            data=dataset,
            x="Longitude",
            y="Latitude",
            hue=dataset.select_dtypes(include=["number"]).columns[0],
        )
        plt.title("Geographic Analysis")
        save_visualisation(plt, outputDir, "geographic_analysis.png")
    else:
        print("Latitude and Longitude columns are missing.")


# Function to visualise categorical data
def visualise_categorical_data(dataset, outputDir):
    """
    Parameters:
    1. dataset: A pandas dataframe
    2. outputDir (A string): Directory to save the visualisation
    """
    non_numeric_df = dataset.select_dtypes(exclude=["number"])
    for col in non_numeric_df.columns:
        # Count the unique values in the column
        value_counts = dataset[col].value_counts()
        num_unique_values = len(value_counts)

        def adjust_labels(ax, labels, max_chars_per_line=10, rotate=False):
            """
            Helper function to adjust labels by splitting long ones into multiple lines
            and optionally rotating them.
            """
            new_labels = []
            for label in labels:
                split_label = "\n".join(
                    [
                        label[i : i + max_chars_per_line]
                        for i in range(0, len(label), max_chars_per_line)
                    ]
                )
                new_labels.append(split_label)
            ax.set_xticks(range(len(new_labels)))
            ax.set_xticklabels(
                new_labels,
                rotation=90 if rotate else 0,
                ha="center" if rotate else "right",
            )

        if num_unique_values <= 15:
            # Case 1: Bars <= 15, enhance readability
            plt.figure(figsize=(12, 8))
            ax = sns.countplot(x=col, data=dataset, order=value_counts.index)
            plt.title(f"Distribution of {col}")
            adjust_labels(ax, value_counts.index, max_chars_per_line=10, rotate=False)
            plt.tight_layout(rect=(0, 0, 1, 0.95))
            plt.subplots_adjust(bottom=0.25)
            save_visualisation(plt, outputDir, f"{col}_distribution.png")

        elif 15 < num_unique_values <= 30:
            # Case 2: 15 < bars <=30, enhance readability
            plt.figure(figsize=(12, 8))
            ax = sns.countplot(x=col, data=dataset, order=value_counts.index)
            plt.title(f"Distribution of {col}")
            adjust_labels(ax, value_counts.index, max_chars_per_line=15, rotate=True)
            plt.tight_layout(rect=[0, 0, 1, 0.95])
            plt.subplots_adjust(bottom=0.35)
            save_visualisation(plt, outputDir, f"{col}_distribution.png")

        else:
            # Case 3: Bars > 30, two graphs (top 15 and bottom 15 value-wise)
            top_15 = value_counts.head(15)
            bottom_15 = value_counts.tail(15)

            # Top 15 graph
            plt.figure(figsize=(12, 8))
            ax = sns.barplot(x=top_15.index, y=top_15.values)
            plt.title(f"Top 15 Distribution of {col}")
            adjust_labels(ax, top_15.index, max_chars_per_line=15, rotate=True)
            plt.tight_layout(rect=(0, 0, 1, 0.95))
            plt.subplots_adjust(bottom=0.35)
            save_visualisation(plt, outputDir, f"{col}_top_15_distribution.png")

            # Bottom 15 graph
            plt.figure(figsize=(12, 8))
            ax = sns.barplot(x=bottom_15.index, y=bottom_15.values)
            plt.title(f"Bottom 15 Distribution of {col}")
            adjust_labels(ax, bottom_15.index, max_chars_per_line=15, rotate=True)
            plt.tight_layout(rect=(0, 0, 1, 0.95))
            plt.subplots_adjust(bottom=0.35)
            save_visualisation(plt, outputDir, f"{col}_bottom_15_distribution.png")


if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Filename required")
        sys.exit()

    outputDir = "."
    for filename in sys.argv[1:]:
        # outputDir = filename.split(".")[0]
        # outputDir = outputDir.split("/")[-1]
        # os.mkdir(outputDir)
        dataset = open_file(filename)
        summary = summarize(dataset)

        insights = question_llm(
            "Analyse and provide insights from the dataset.",
            context=f"dataset summary: {summary} \n Missing values: {dataset.isnull().sum()}",
        )
        print(insights)

        outliers_plt = visualise_outliers(dataset, outputDir)
        correlation_matrix = visualise_correlation(dataset, outputDir)
        visualise_time_series(dataset, outputDir)
        visualise_geographic_analysis(dataset, outputDir)

        llm_custom_plot = ask_llm_to_suggest_plot(dataset)
        try:
            code = ask_llm_to_plot(dataset, llm_custom_plot)
            if code:
                code = code.replace("```", "")
                code = code.replace("python", "")
                exec(code)
        except Exception as e:
            print(f"Error in custom plot: {e}")

        # Numeric analysis
        numeric_insights = question_llm(
            "Provide me insights about the following numeric columns.",
            context=f"Numeric columns summary:\n{dataset.select_dtypes(include=['number']).describe()}",
        )

        # Generating the story
        story = question_llm(
            "Generate a nice and creative story from the analysis",
            context=f"Dataset Analysis:\nSummary: {summary}\nMissing Values: {dataset.isnull().sum()}\nInsights: {insights}\nNumeric Column Insights: {numeric_insights}",
        )

        # Questioning llm with images
        outliers_summary = ask_llm_with_image(
            os.path.join(outputDir, "outliers_boxplot.png"),
            content="What can I infer from this plot? It is plotted to show outliers in the dataset.",
        )

        correlation_summary = ask_llm_with_image(
            os.path.join(outputDir, "correlation_matrix_heatmap.png"),
            content="What can I infer from this plot?",
        )
        try:
            with open(os.path.join(outputDir, "README.md"), "w") as f:
                f.write("# Data Analysis Report\n\n")
                f.write("## Overview\n")
                f.write(f"File: {filename}\n\n")
                f.write("## Insights\n")
                f.write(f"{insights}\n\n")
                f.write("## Numeric Insights\n")
                f.write(f"{numeric_insights}\n\n")
                f.write("## Story\n")
                f.write(f"{story}\n")
                f.write("## Outliers Analysis\n")
                f.write("![Image](./outliers_bloxplot.png)\n")
                f.write(f"{outliers_summary}\n")
                f.write("## Correlation Matrix Analysis\n")
                f.write("![Image](./correlation_matrix_heatmap.png)\n")
                f.write(f"{correlation_summary}\n")
                f.write("## Custom LLM Plot")
                f.write("![Image](./custom_llm_plot.png)\n")
                f.write("## Summary Statistics\n")
                f.write(f"{summary}\n\n")
                f.write("## Missing Values\n")
                f.write(f"{dataset.isnull().sum()}\n\n")

        except Exception as e:
            print(f"Error writing to README.md: {e}")

        print("Analysis complete! Results saved to README.md.")

    # question_llm("Are you ready?")
